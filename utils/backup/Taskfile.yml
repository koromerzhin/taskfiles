version: '3'

# Taskfile pour les utilitaires de sauvegarde

vars:
  BACKUP_DIR: '{{.BACKUP_DIR | default "./backups"}}'
  TIMESTAMP: '{{now | date "2006-01-02_15-04-05"}}'

tasks:
  create:
    desc: "Cr√©e une sauvegarde horodat√©e du projet"
    silent: true
    summary: |
      Cr√©e une archive tar.gz du projet excluant les dossiers temporaires.
      
      Variables:
      - BACKUP_DIR: Dossier de destination (d√©faut: ./backups)
      - EXCLUDE_PATTERNS: Patterns √† exclure (d√©faut: node_modules,.git,tmp)
      
      Exemple:
      task utils:backup:create
      task utils:backup:create BACKUP_DIR=/tmp/backups
    vars:
      EXCLUDE_PATTERNS: '{{.EXCLUDE_PATTERNS | default "node_modules,.git,tmp,*.log,dist,build"}}'
    cmds:
    - |
      echo "üì¶ Cr√©ation d'une sauvegarde du projet..."
      mkdir -p "{{.BACKUP_DIR}}"
      
      project_name=$(basename "$(pwd)")
      backup_file="{{.BACKUP_DIR}}/${project_name}_{{.TIMESTAMP}}.tar.gz"
      
      echo "üìÅ Sauvegarde vers: $backup_file"
      
      # Conversion des patterns d'exclusion en options tar
      exclude_opts=""
      IFS=',' read -ra patterns <<< "{{.EXCLUDE_PATTERNS}}"
      for pattern in "${patterns[@]}"; do
        exclude_opts="$exclude_opts --exclude=$pattern"
      done
      
      # Cr√©ation de l'archive
      if tar czf "$backup_file" $exclude_opts -C .. "$project_name"; then
        size=$(ls -lh "$backup_file" | awk '{print $5}')
        echo "‚úÖ Sauvegarde cr√©√©e avec succ√®s ($size)"
        echo "üìÑ Fichier: $backup_file"
      else
        echo "‚ùå Erreur lors de la cr√©ation de la sauvegarde"
        exit 1
      fi

  list:
    desc: "Liste les sauvegardes disponibles"
    silent: true
    summary: |
      Affiche la liste des sauvegardes dans le dossier de destination.
      
      Variables:
      - BACKUP_DIR: Dossier √† v√©rifier (d√©faut: ./backups)
    cmds:
    - |
      if [ ! -d "{{.BACKUP_DIR}}" ]; then
        echo "‚ùå Dossier de sauvegarde '{{.BACKUP_DIR}}' introuvable"
        exit 1
      fi
      
      echo "üìã Sauvegardes disponibles dans '{{.BACKUP_DIR}}' :"
      echo ""
      
      backups_found=0
      for backup in "{{.BACKUP_DIR}}"/*.tar.gz; do
        if [ -f "$backup" ]; then
          size=$(ls -lh "$backup" | awk '{print $5}')
          date=$(ls -l "$backup" | awk '{print $6, $7, $8}')
          echo "  üì¶ $(basename "$backup") ($size) - $date"
          backups_found=$((backups_found + 1))
        fi
      done
      
      if [ $backups_found -eq 0 ]; then
        echo "  Aucune sauvegarde trouv√©e"
        echo ""
        echo "üí° Cr√©ez une sauvegarde avec 'task utils:backup:create'"
      else
        echo ""
        echo "üìä $backups_found sauvegarde(s) trouv√©e(s)"
      fi

  restore:
    desc: "Restaure une sauvegarde sp√©cifique"
    silent: true
    summary: |
      Restaure une sauvegarde depuis une archive.
      
      Variables:
      - BACKUP_FILE: Fichier de sauvegarde √† restaurer (requis)
      - RESTORE_DIR: Dossier de restauration (d√©faut: ./)
      
      Exemple:
      task utils:backup:restore BACKUP_FILE=./backups/project_2023-10-03_14-30-45.tar.gz
    vars:
      RESTORE_DIR: '{{.RESTORE_DIR | default "./"}}'
    cmds:
    - |
      if [ -z "{{.BACKUP_FILE}}" ]; then
        echo "‚ùå BACKUP_FILE est requis"
        echo "üìã Sauvegardes disponibles :"
        task utils:backup:list
        exit 1
      fi
      
      if [ ! -f "{{.BACKUP_FILE}}" ]; then
        echo "‚ùå Fichier de sauvegarde '{{.BACKUP_FILE}}' introuvable"
        exit 1
      fi
      
      echo "üì§ Restauration de la sauvegarde '{{.BACKUP_FILE}}'..."
      echo "üìÅ Vers: {{.RESTORE_DIR}}"
      
      # Demande de confirmation
      read -p "Confirmer la restauration ? [y/N] " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "‚ùå Restauration annul√©e"
        exit 1
      fi
      
      # Extraction
      if tar xzf "{{.BACKUP_FILE}}" -C "{{.RESTORE_DIR}}"; then
        echo "‚úÖ Restauration termin√©e avec succ√®s"
      else
        echo "‚ùå Erreur lors de la restauration"
        exit 1
      fi

  clean:
    desc: "Nettoie les anciennes sauvegardes"
    silent: true
    summary: |
      Supprime les sauvegardes plus anciennes que le nombre de jours sp√©cifi√©.
      
      Variables:
      - DAYS: Nombre de jours √† conserver (d√©faut: 30)
      - BACKUP_DIR: Dossier des sauvegardes (d√©faut: ./backups)
    vars:
      DAYS: '{{.DAYS | default "30"}}'
    cmds:
    - |
      if [ ! -d "{{.BACKUP_DIR}}" ]; then
        echo "‚ùå Dossier de sauvegarde '{{.BACKUP_DIR}}' introuvable"
        exit 1
      fi
      
      echo "üßπ Nettoyage des sauvegardes de plus de {{.DAYS}} jours..."
      
      cleaned=0
      total_size=0
      
      find "{{.BACKUP_DIR}}" -name "*.tar.gz" -type f -mtime +{{.DAYS}} | while read -r backup; do
        if [ -f "$backup" ]; then
          size=$(stat -f%z "$backup" 2>/dev/null || stat -c%s "$backup" 2>/dev/null || echo "0")
          echo "üóëÔ∏è  Suppression: $(basename "$backup")"
          rm -f "$backup"
          cleaned=$((cleaned + 1))
          total_size=$((total_size + size))
        fi
      done
      
      if [ $cleaned -eq 0 ]; then
        echo "‚úÖ Aucune sauvegarde ancienne trouv√©e"
      else
        echo "‚úÖ $cleaned sauvegarde(s) supprim√©e(s)"
        echo "üíæ Espace lib√©r√©: $(numfmt --to=iec $total_size 2>/dev/null || echo "$total_size bytes")"
      fi