version: '3'

tasks:
  deploy:
    desc: "D√©ploie une stack Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      D√©ploie une stack Docker en utilisant docker stack deploy.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose √† utiliser (d√©faut: docker-compose.yml)

      Exemples:
      task docker:stack:deploy
      task docker:stack:deploy STACK_NAME=mon-app
      task docker:stack:deploy STACK_NAME=mon-app COMPOSE_FILE=docker-stack.yml
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        echo "üìÅ Fichiers disponibles :"
        find . -name "docker-*.yml" -o -name "*compose*.yml" 2>/dev/null || echo "   Aucun fichier trouv√©"
        exit 1
      fi

      echo "üöÄ D√©ploiement de la stack '{{.STACK_NAME}}' avec le fichier '{{.COMPOSE_FILE}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' d√©ploy√©e avec succ√®s"

  deploy:with-build:
    desc: "D√©ploie une stack apr√®s avoir construit les images"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      Construit les images puis d√©ploie la stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose (d√©faut: docker-compose.yml)
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        exit 1
      fi

      echo "üî® Construction des images..."
      docker-compose -f {{.COMPOSE_FILE}} build

      echo "üöÄ D√©ploiement de la stack '{{.STACK_NAME}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' construite et d√©ploy√©e"

  update:
    desc: "Met √† jour une stack existante"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      Met √† jour une stack Docker Swarm existante.
      √âquivalent √† docker stack deploy mais avec des messages sp√©cifiques √† la mise √† jour.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose (d√©faut: docker-compose.yml)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üîÑ Mise √† jour de la stack '{{.STACK_NAME}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' mise √† jour"

  remove:
    desc: "Supprime une stack Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Supprime compl√®tement une stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack √† supprimer (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üóëÔ∏è  Suppression de la stack '{{.STACK_NAME}}'..."
      docker stack rm {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' supprim√©e"

  list:
    desc: "Liste toutes les stacks Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: "Affiche la liste de toutes les stacks d√©ploy√©es"
    cmds:
    - echo "üìã Stacks Docker Swarm d√©ploy√©es :"
    - docker stack ls

  services:
    desc: "Liste les services d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Affiche tous les services d'une stack sp√©cifique.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üîß Services de la stack '{{.STACK_NAME}}' :"
      docker stack services {{.STACK_NAME}}

  ps:
    desc: "Affiche les t√¢ches/conteneurs d'une stack"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche toutes les t√¢ches (conteneurs) d'une stack.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üì¶ T√¢ches de la stack '{{.STACK_NAME}}' :"
      docker stack ps {{.STACK_NAME}}

  logs:
    desc: "Affiche les logs d'un service de la stack"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche les logs d'un service sp√©cifique dans une stack.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SERVICE_NAME: Nom du service (requis)

      Exemple:
      task docker:stack:logs STACK_NAME=mon-app SERVICE_NAME=web
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo "üîß Services disponibles pour la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        exit 1
      fi

      echo "üìÑ Logs du service '{{.STACK_NAME}}_{{.SERVICE_NAME}}' :"
      docker service logs {{.STACK_NAME}}_{{.SERVICE_NAME}} --follow

  validate:
    desc: "Valide un fichier docker-compose pour Docker Swarm"
    silent: true
    vars:
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Valide la syntaxe d'un fichier docker-compose avant d√©ploiement.

      Variables:
      - COMPOSE_FILE: Fichier √† valider (d√©faut: docker-compose.yml)
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        exit 1
      fi

      echo "‚úÖ Validation du fichier '{{.COMPOSE_FILE}}'..."
      docker-compose -f {{.COMPOSE_FILE}} config
      echo "‚úÖ Fichier valide"

  check:containers:ready:
    desc: "V√©rifie que les conteneurs sp√©cifi√©s sont pr√™ts"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      V√©rifie que les conteneurs d'une liste sont tous actifs et en bonne sant√©.
      Attend et v√©rifie p√©riodiquement jusqu'√† ce que tous soient pr√™ts ou timeout.

      Variables:
      - CONTAINERS: Liste des conteneurs s√©par√©s par des virgules (ex: "traefik,portainer")
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications en secondes (d√©faut: 10)

      Exemple:
      task docker:stack:check:containers:ready CONTAINERS="traefik,portainer" STACK_NAME=mon-app
    vars:
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      CONTAINERS: '{{.CONTAINERS | default ""}}'
    cmds:
    - |
      if [ -z "{{.CONTAINERS}}" ]; then
        echo "‚ùå CONTAINERS est requis (ex: 'traefik,portainer')"
        exit 1
      fi

      echo "üîç V√©rification de l'√©tat des conteneurs : {{.CONTAINERS}}"
      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle de v√©rification: {{.CHECK_INTERVAL}}s"
      echo ""

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))

      # Convertir la liste en tableau compatible POSIX
      containers_list="{{.CONTAINERS}}"
      containers_clean=$(echo "$containers_list" | tr ',' ' ')

      # Compteur de v√©rifications
      check_count=0

      while true; do
        current_time=$(date +%s)
        check_count=$((check_count + 1))
        
        # V√©rifier le timeout
        if [ $current_time -gt $timeout_time ]; then
          echo ""
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). Tous les conteneurs ne sont pas encore pr√™ts."
          echo "üìã √âtat final des conteneurs :"
          docker ps --filter "name={{.STACK_NAME}}" --format "table {{.Names}}\t{{.Status}}"
          exit 1
        fi
        
        all_ready=true
        ready_containers=""
        missing_containers=""
        
        # V√©rifier chaque conteneur
        for container in $containers_clean; do
          container=$(echo "$container" | xargs)  # Trim whitespace
          
          if docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Names}}" | grep -q "{{.STACK_NAME}}_${container}"; then
            ready_containers="$ready_containers $container"
          else
            missing_containers="$missing_containers $container"
            all_ready=false
          fi
        done
        
        # Affichage de l'√©tat
        elapsed=$((current_time - start_time))
        echo "‚è≥ V√©rification #$check_count (${elapsed}s/{{.TIMEOUT}}s)"
        
        if [ -n "$ready_containers" ]; then
          echo "  ‚úÖ Pr√™ts     :$ready_containers"
        fi
        
        if [ -n "$missing_containers" ]; then
          echo "  ‚è≥ En attente :$missing_containers"
        fi
        
        # Si tous les conteneurs sont pr√™ts, on sort de la boucle
        if [ "$all_ready" = true ]; then
          echo ""
          echo "üéâ Succ√®s ! Tous les conteneurs sont actifs !"
          echo "‚è±Ô∏è  Temps total d'attente : ${elapsed}s"
          echo ""
          echo "üìã Conteneurs actifs :"
          for container in $containers_clean; do
            container=$(echo "$container" | xargs)
            status=$(docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Status}}")
            echo "  ‚úÖ ${container} - $status"
          done
          break
        fi
        
        echo ""
        sleep {{.CHECK_INTERVAL}}
      done

  wait:containers:ready:
    desc: "Attend que les conteneurs sp√©cifi√©s soient pr√™ts"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Attend que tous les conteneurs d'une liste soient actifs et en bonne sant√©.
      Effectue des v√©rifications p√©riodiques jusqu'au timeout.

      Variables:
      - CONTAINERS: Liste des conteneurs s√©par√©s par des virgules (ex: "traefik,portainer")
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications en secondes (d√©faut: 10)

      Exemple:
      task docker:stack:wait:containers:ready CONTAINERS="traefik,portainer" TIMEOUT=600
    vars:
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      CONTAINERS: '{{.CONTAINERS | default ""}}'
    cmds:
    - |
      if [ -z "{{.CONTAINERS}}" ]; then
        echo "‚ùå CONTAINERS est requis (ex: 'traefik,portainer')"
        exit 1
      fi

      echo "‚è≥ Attente que les conteneurs soient pr√™ts : {{.CONTAINERS}}"
      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle de v√©rification: {{.CHECK_INTERVAL}}s"

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))

      # Convertir la liste en format compatible POSIX
      containers_list="{{.CONTAINERS}}"
      containers_clean=$(echo "$containers_list" | tr ',' ' ')

      while true; do
        current_time=$(date +%s)
        
        if [ $current_time -gt $timeout_time ]; then
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). Les conteneurs ne sont pas tous pr√™ts."
          exit 1
        fi
        
        all_ready=true
        
        for container in $containers_clean; do
          container=$(echo "$container" | xargs)  # Trim whitespace
          
          if ! docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Names}}" | grep -q "{{.STACK_NAME}}_${container}"; then
            all_ready=false
            break
          fi
        done
        
        if [ "$all_ready" = true ]; then
          echo "‚úÖ Tous les conteneurs sont pr√™ts!"
          break
        fi
        
        elapsed=$((current_time - start_time))
        echo "‚è≥ Attente... (${elapsed}s/{{.TIMEOUT}}s)"
        sleep {{.CHECK_INTERVAL}}
      done
