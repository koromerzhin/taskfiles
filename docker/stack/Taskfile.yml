version: '3'

tasks:
  deploy:
    desc: "D√©ploie une stack Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      D√©ploie une stack Docker en utilisant docker stack deploy.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose √† utiliser (d√©faut: docker-compose.yml)

      Exemples:
      task docker:stack:deploy
      task docker:stack:deploy STACK_NAME=mon-app
      task docker:stack:deploy STACK_NAME=mon-app COMPOSE_FILE=docker-stack.yml
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        echo "üìÅ Fichiers disponibles :"
        find . -name "docker-*.yml" -o -name "*compose*.yml" 2>/dev/null || echo "   Aucun fichier trouv√©"
        exit 1
      fi

      echo "üöÄ D√©ploiement de la stack '{{.STACK_NAME}}' avec le fichier '{{.COMPOSE_FILE}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' d√©ploy√©e avec succ√®s"

  deploy:with-build:
    desc: "D√©ploie une stack apr√®s avoir construit les images"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      Construit les images puis d√©ploie la stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose (d√©faut: docker-compose.yml)
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        exit 1
      fi

      echo "üî® Construction des images..."
      docker compose -f {{.COMPOSE_FILE}} build

      echo "üöÄ D√©ploiement de la stack '{{.STACK_NAME}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' construite et d√©ploy√©e"

  update:
    desc: "Met √† jour une stack existante"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      Met √† jour une stack Docker Swarm existante.
      √âquivalent √† docker stack deploy mais avec des messages sp√©cifiques √† la mise √† jour.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose (d√©faut: docker-compose.yml)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üîÑ Mise √† jour de la stack '{{.STACK_NAME}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' mise √† jour"

  remove:
    desc: "Supprime une stack Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Supprime compl√®tement une stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack √† supprimer (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üóëÔ∏è  Suppression de la stack '{{.STACK_NAME}}'..."
      docker stack rm {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' supprim√©e"

  list:
    desc: "Liste toutes les stacks Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: "Affiche la liste de toutes les stacks d√©ploy√©es"
    cmds:
    - echo "üìã Stacks Docker Swarm d√©ploy√©es :"
    - docker stack ls

  services:
    desc: "Liste les services d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Affiche tous les services d'une stack sp√©cifique.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üîß Services de la stack '{{.STACK_NAME}}' :"
      docker stack services {{.STACK_NAME}}

  ps:
    desc: "Affiche les t√¢ches/conteneurs d'une stack"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche toutes les t√¢ches (conteneurs) d'une stack.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üì¶ T√¢ches de la stack '{{.STACK_NAME}}' :"
      docker stack ps {{.STACK_NAME}}

  logs:
    desc: "Affiche les logs d'un service de la stack"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche les logs d'un service sp√©cifique dans une stack.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SERVICE_NAME: Nom du service (requis)

      Exemple:
      task docker:stack:logs STACK_NAME=mon-app SERVICE_NAME=web
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo "üîß Services disponibles pour la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        exit 1
      fi

      echo "üìÑ Logs du service '{{.STACK_NAME}}_{{.SERVICE_NAME}}' :"
      docker service logs {{.STACK_NAME}}_{{.SERVICE_NAME}} --follow

  validate:
    desc: "Valide un fichier docker-compose pour Docker Swarm"
    silent: true
    vars:
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Valide la syntaxe d'un fichier docker-compose avant d√©ploiement.

      Variables:
      - COMPOSE_FILE: Fichier √† valider (d√©faut: docker-compose.yml)
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        exit 1
      fi

      echo "‚úÖ Validation du fichier '{{.COMPOSE_FILE}}'..."
      docker compose -f {{.COMPOSE_FILE}} config
      echo "‚úÖ Fichier valide"

  check:containers:ready:
    desc: "V√©rifie que les conteneurs sp√©cifi√©s sont pr√™ts"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      V√©rifie que les conteneurs ou services sp√©cifi√©s sont tous actifs et en bonne sant√©.
      Attend et v√©rifie p√©riodiquement jusqu'√† ce que tous soient pr√™ts ou timeout.

      Variables:
      - CONTAINERS: Liste des conteneurs s√©par√©s par des virgules (ex: "traefik,portainer")
      - SERVICES: Liste des services s√©par√©s par des virgules (ex: "mariadb,mercure,redis")
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications en secondes (d√©faut: 10)

      Exemple:
      task docker:stack:check:containers:ready CONTAINERS="traefik,portainer" STACK_NAME=mon-app
      task docker:stack:check:containers:ready SERVICES="mariadb,mercure,redis" STACK_NAME=mon-app
    vars:
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      CONTAINERS: '{{.CONTAINERS | default ""}}'
      SERVICES: '{{.SERVICES | default ""}}'
    cmds:
    - |
      if [ -z "{{.CONTAINERS}}" ] && [ -z "{{.SERVICES}}" ]; then
        echo "‚ùå CONTAINERS ou SERVICES est requis (ex: 'traefik,portainer' ou 'mariadb,mercure,redis')"
        exit 1
      fi

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))
      check_count=0

      if [ -n "{{.CONTAINERS}}" ]; then
        echo "üîç V√©rification de l'√©tat des conteneurs demand√©s : {{.CONTAINERS}}"
        containers_list="{{.CONTAINERS}}"
        containers_clean=$(echo "$containers_list" | tr ',' ' ')
      fi

      if [ -n "{{.SERVICES}}" ]; then
        echo "üîç V√©rification de l'√©tat des services : {{.SERVICES}}"
        services_list="{{.SERVICES}}"
        services_clean=$(echo "$services_list" | tr ',' ' ')
      fi

      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle de v√©rification: {{.CHECK_INTERVAL}}s"
      echo ""

      while true; do
        current_time=$(date +%s)
        check_count=$((check_count + 1))

        # Timeout
        if [ $current_time -gt $timeout_time ]; then
          echo ""
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). Tous les √©l√©ments ne sont pas encore pr√™ts."
          if [ -n "{{.CONTAINERS}}" ]; then
            echo "üìã √âtat final des conteneurs :"
            docker ps --filter "name={{.STACK_NAME}}" --format "table {{.Names}}\t{{.Status}}"
          fi
          if [ -n "{{.SERVICES}}" ]; then
            echo "üìã √âtat final des services :"
            for service in $services_clean; do
              service=$(echo "$service" | xargs)
              service_full_name="{{.STACK_NAME}}_${service}"
              replicas=$(docker service ls --filter "name=$service_full_name" --format "{{.Replicas}}" 2>/dev/null || echo "non trouv√©")
              echo "   $service: $replicas"
            done
          fi
          exit 1
        fi

        all_ready=true
        ready_containers=""
        missing_containers=""
        ready_services=""
        pending_services=""

        # V√©rification des conteneurs demand√©s uniquement
        if [ -n "{{.CONTAINERS}}" ]; then
          for container in $containers_clean; do
            container=$(echo "$container" | xargs)
            # V√©rifie uniquement le conteneur explicitement demand√©
            if docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Names}}" | grep -wq "{{.STACK_NAME}}_${container}"; then
              ready_containers="$ready_containers $container"
            else
              missing_containers="$missing_containers $container"
              all_ready=false
            fi
          done
        fi

        # V√©rification des services
        if [ -n "{{.SERVICES}}" ]; then
          for service in $services_clean; do
            service=$(echo "$service" | xargs)
            service_full_name="{{.STACK_NAME}}_${service}"
            if docker service ls --filter "name=$service_full_name" --format "{{.Replicas}}" | grep -q "1/1\|[2-9]/[2-9]"; then
              ready_services="$ready_services $service"
            else
              pending_services="$pending_services $service"
              all_ready=false
            fi
          done
        fi

        # Affichage de l'√©tat
        elapsed=$((current_time - start_time))
        echo "‚è≥ V√©rification #$check_count (${elapsed}s/{{.TIMEOUT}}s)"
        if [ -n "$ready_containers" ]; then
          echo "  ‚úÖ Conteneurs pr√™ts     :$ready_containers"
        fi
        if [ -n "$missing_containers" ]; then
          echo "  ‚è≥ Conteneurs en attente :$missing_containers"
        fi
        if [ -n "$ready_services" ]; then
          echo "  ‚úÖ Services actifs      :$ready_services"
        fi
        if [ -n "$pending_services" ]; then
          echo "  ‚è≥ Services en attente  :$pending_services"
        fi

        # Succ√®s si tout est pr√™t
        if [ "$all_ready" = true ]; then
          echo ""
          echo "üéâ Succ√®s ! Tous les √©l√©ments sont actifs !"
          echo "‚è±Ô∏è  Temps total d'attente : ${elapsed}s"
          if [ -n "{{.CONTAINERS}}" ]; then
            echo "üìã Conteneurs actifs :"
            for container in $containers_clean; do
              container=$(echo "$container" | xargs)
              status=$(docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Status}}")
              echo "  ‚úÖ ${container} - $status"
            done
          fi
          if [ -n "{{.SERVICES}}" ]; then
            echo "üìã Services v√©rifi√©s :"
            for service in $services_clean; do
              service=$(echo "$service" | xargs)
              service_full_name="{{.STACK_NAME}}_${service}"
              replicas=$(docker service ls --filter "name=$service_full_name" --format "{{.Replicas}}")
              echo "  ‚úÖ $service ($replicas)"
            done
          fi
          break
        fi

        echo ""
        sleep {{.CHECK_INTERVAL}}
      done

  exec:
    desc: "Ex√©cute une commande dans un conteneur d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
      COMMAND: '{{.COMMAND | default "sh"}}'
      TASK_FILTER: '{{.TASK_FILTER | default "running"}}'
      INTERACTIVE: '{{.INTERACTIVE | default "true"}}'
    summary: |
      Ex√©cute une commande dans un conteneur appartenant √† une stack Docker Swarm.

      Variables requises:
      - SERVICE_NAME: Nom du service dans la stack (ex: "web", "api", "database")

      Variables optionnelles:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMMAND: Commande √† ex√©cuter (d√©faut: sh)
      - TASK_FILTER: Filtre pour les t√¢ches (d√©faut: running)
      - INTERACTIVE: Mode interactif (d√©faut: true)

      Exemples:
      task docker:stack:exec SERVICE_NAME=web
      task docker:stack:exec SERVICE_NAME=web COMMAND="ls -la"
      task docker:stack:exec SERVICE_NAME=api COMMAND="/app/scripts/migrate.sh"
      task docker:stack:exec SERVICE_NAME=database COMMAND="mysql -u root -p" INTERACTIVE=true
      task docker:stack:exec STACK_NAME=production SERVICE_NAME=worker COMMAND="python manage.py migrate"
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        if docker stack ls --format "{{.Name}}" | grep -q "^{{.STACK_NAME}}$"; then
          docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        else
          echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
          echo "üìã Stacks disponibles :"
          docker stack ls --format "{{.Name}}"
        fi
        exit 1
      fi

      # V√©rifier que la stack existe
      echo "üîç V√©rification de l'existence de la stack '{{.STACK_NAME}}'..."
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi
      echo "‚úÖ Stack '{{.STACK_NAME}}' trouv√©e"

      service_full_name="{{.STACK_NAME}}_{{.SERVICE_NAME}}"

      # V√©rifier que le service existe
      echo "üîç V√©rification de l'existence du service '$service_full_name'..."
      if ! docker service ls | awk 'NR>1 {print $2}' | grep -q "^$service_full_name$"; then
        echo "‚ùå Le service '$service_full_name' n'existe pas"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} | awk 'NR>1 {print $2}'
        exit 1
      fi
      echo "‚úÖ Service '$service_full_name' trouv√©"

      # Trouver le conteneur actif pour ce service
      echo "üîç Recherche d'un conteneur actif pour le service '$service_full_name'..."

      container_id=$(docker ps | grep "$service_full_name" | awk '{print $1}' | head -n 1)

      if [ -z "$container_id" ]; then
        echo "‚ùå Aucun conteneur actif trouv√© pour le service '$service_full_name'"
        echo ""
        echo "üìã √âtat des t√¢ches pour ce service :"
        docker service ps $service_full_name
        exit 1
      fi

      container_name=$(docker ps | grep "$container_id" | awk '{print $NF}')
      echo "‚úÖ Conteneur trouv√© : $container_name ($container_id)"
      echo "üöÄ Ex√©cution de la commande : {{.COMMAND}}"
      echo ""

      # Pr√©parer les options Docker exec
      docker_options=""
      # V√©rifier si on est dans un environnement CI/CD o√π TTY n'est pas disponible
      if [ "${DOCKER_INTERACTIVE:-true}" = "false" ] || [ "${CI:-false}" = "true" ] || [ "${GITHUB_ACTIONS:-false}" = "true" ]; then
        # En CI/CD, ne pas utiliser le mode interactif
        docker_options=""
      elif [ "{{.INTERACTIVE}}" = "true" ]; then
        docker_options="-it"
      fi      # Ex√©cuter la commande
      docker exec $docker_options $container_id {{.COMMAND}}

  shell:
    desc: "Acc√®de au shell (bash ou sh) d'un conteneur dans une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
      SHELL_TYPE: '{{.SHELL_TYPE | default "auto"}}'
      EXEC_USER: '{{.EXEC_USER | default ""}}'
    summary: |
      Acc√®de au shell interactif (bash ou sh) d'un conteneur appartenant √† une stack Docker Swarm.
      D√©tecte automatiquement le shell disponible (bash prioritaire, sinon sh).

      Variables requises:
      - SERVICE_NAME: Nom du service dans la stack (ex: "web", "api", "database")

      Variables optionnelles:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SHELL_TYPE: Type de shell √† utiliser - "bash", "sh", "auto" (d√©faut: auto)
      - EXEC_USER: Utilisateur pour l'ex√©cution (d√©faut: utilisateur par d√©faut du conteneur)

      Exemples:
      task docker:stack:shell SERVICE_NAME=web
      task docker:stack:shell SERVICE_NAME=api SHELL_TYPE=bash
      task docker:stack:shell SERVICE_NAME=database EXEC_USER=root
      task docker:stack:shell STACK_NAME=production SERVICE_NAME=worker SHELL_TYPE=sh
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        if docker stack ls --format "{{.Name}}" | grep -q "^{{.STACK_NAME}}$"; then
          docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        else
          echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
          echo "üìã Stacks disponibles :"
          docker stack ls --format "{{.Name}}"
        fi
        exit 1
      fi

      # V√©rifier que la stack existe
      echo "üîç V√©rification de l'existence de la stack '{{.STACK_NAME}}'..."
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi
      echo "‚úÖ Stack '{{.STACK_NAME}}' trouv√©e"

      service_full_name="{{.STACK_NAME}}_{{.SERVICE_NAME}}"

      # V√©rifier que le service existe
      echo "üîç V√©rification de l'existence du service '$service_full_name'..."
      if ! docker service ls | awk 'NR>1 {print $2}' | grep -q "^$service_full_name$"; then
        echo "‚ùå Le service '$service_full_name' n'existe pas"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} | awk 'NR>1 {print $2}'
        exit 1
      fi
      echo "‚úÖ Service '$service_full_name' trouv√©"

      # Trouver le conteneur actif pour ce service
      echo "üîç Recherche d'un conteneur actif pour le service '$service_full_name'..."

      container_id=$(docker ps | grep "$service_full_name" | awk '{print $1}' | head -n 1)

      if [ -z "$container_id" ]; then
        echo "‚ùå Aucun conteneur actif trouv√© pour le service '$service_full_name'"
        echo ""
        echo "üìã √âtat des t√¢ches pour ce service :"
        docker service ps $service_full_name
        exit 1
      fi

      container_name=$(docker ps | grep "$container_id" | awk '{print $NF}')
      echo "‚úÖ Conteneur trouv√© : $container_name ($container_id)"

      # D√©terminer le shell √† utiliser
      shell_command=""
      shell_type="{{.SHELL_TYPE}}"

      if [ "$shell_type" = "auto" ]; then
        echo "üîç D√©tection automatique du shell disponible..."
        
        # Tester bash en premier
        if docker exec $container_id which bash >/dev/null 2>&1; then
          shell_command="bash"
          echo "‚úÖ Bash d√©tect√© et disponible"
        elif docker exec $container_id which sh >/dev/null 2>&1; then
          shell_command="sh"
          echo "‚úÖ Shell sh d√©tect√© et disponible"
        else
          echo "‚ùå Aucun shell compatible trouv√© (bash/sh)"
          echo "üí° Shells disponibles dans le conteneur :"
          docker exec $container_id ls -la /bin/*sh 2>/dev/null || echo "   Aucun shell trouv√© dans /bin/"
          exit 1
        fi
      else
        shell_command="$shell_type"
        echo "üîß Shell sp√©cifi√© : $shell_command"
        
        # V√©rifier que le shell sp√©cifi√© existe
        if ! docker exec $container_id which $shell_command >/dev/null 2>&1; then
          echo "‚ùå Shell '$shell_command' non disponible dans le conteneur"
          echo "üí° Shells disponibles :"
          docker exec $container_id ls -la /bin/*sh 2>/dev/null || echo "   Aucun shell trouv√© dans /bin/"
          exit 1
        fi
      fi

      # Pr√©parer les options pour docker exec
      docker_options=""
      # V√©rifier si on est dans un environnement CI/CD o√π TTY n'est pas disponible
      if [ "${DOCKER_INTERACTIVE:-true}" = "false" ] || [ "${CI:-false}" = "true" ] || [ "${GITHUB_ACTIONS:-false}" = "true" ]; then
        # En CI/CD, ne pas utiliser le mode interactif
        docker_options=""
        echo "‚ö†Ô∏è  Mode non-interactif d√©tect√© (CI/CD)"
      else
        # En environnement normal, utiliser le mode interactif pour shell
        docker_options="-it"
      fi      # Ajouter l'utilisateur si sp√©cifi√©
      if [ -n "{{.EXEC_USER}}" ]; then
        docker_options="$docker_options --user {{.EXEC_USER}}"
        echo "üë§ Utilisateur : {{.EXEC_USER}}"
      fi

      echo ""
      echo "üêö Ouverture du shell interactif..."
      echo "   üê≥ Conteneur : $container_name ($container_id)"
      echo "   üêö Shell : $shell_command"
      echo "   ‚å®Ô∏è  Mode : Interactif"
      echo ""
      echo "üí° Tapez 'exit' pour quitter le shell"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      echo ""

      # Lancer le shell interactif
      docker exec $docker_options $container_id $shell_command

  exec:script:
    desc: "Ex√©cute un script dans un conteneur d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
      SCRIPT_PATH: '{{.SCRIPT_PATH | default ""}}'
      SCRIPT_ARGS: '{{.SCRIPT_ARGS | default ""}}'
      TASK_FILTER: '{{.TASK_FILTER | default "running"}}'
      WORKING_DIR: '{{.WORKING_DIR | default ""}}'
    summary: |
      Ex√©cute un script sp√©cifique dans un conteneur appartenant √† une stack Docker Swarm.

      Variables requises:
      - SERVICE_NAME: Nom du service dans la stack (ex: "web", "api", "database")  
      - SCRIPT_PATH: Chemin du script √† ex√©cuter dans le conteneur

      Variables optionnelles:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SCRIPT_ARGS: Arguments √† passer au script (d√©faut: "")
      - TASK_FILTER: Filtre pour les t√¢ches (d√©faut: running)
      - WORKING_DIR: R√©pertoire de travail dans le conteneur (d√©faut: r√©pertoire courant du conteneur)

      Exemples:
      task docker:stack:exec:script SERVICE_NAME=web SCRIPT_PATH="/app/scripts/deploy.sh"
      task docker:stack:exec:script SERVICE_NAME=api SCRIPT_PATH="/app/migrate.py" SCRIPT_ARGS="--force"
      task docker:stack:exec:script SERVICE_NAME=worker SCRIPT_PATH="/scripts/backup.sh" WORKING_DIR="/data"
      task docker:stack:exec:script STACK_NAME=production SERVICE_NAME=app SCRIPT_PATH="/opt/scripts/maintenance.sh" SCRIPT_ARGS="--mode full"
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        if docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
          docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        else
          echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        fi
        exit 1
      fi

      if [ -z "{{.SCRIPT_PATH}}" ]; then
        echo "‚ùå SCRIPT_PATH est requis"
        echo "üí° Exemple: SCRIPT_PATH=/app/scripts/deploy.sh"
        exit 1
      fi

      # V√©rifier que la stack existe
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi

      service_full_name="{{.STACK_NAME}}_{{.SERVICE_NAME}}"

      # V√©rifier que le service existe
      if ! docker service ls --filter "name=$service_full_name" --format "{{.Name}}" | grep -q "^$service_full_name$"; then
        echo "‚ùå Le service '$service_full_name' n'existe pas"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        exit 1
      fi

      # Trouver le conteneur actif pour ce service
      echo "üîç Recherche d'un conteneur actif pour le service '$service_full_name'..."

      container_id=$(docker ps --filter "label=com.docker.swarm.service.name=$service_full_name" --filter "status={{.TASK_FILTER}}" --format "{{.ID}}" | head -n 1)

      if [ -z "$container_id" ]; then
        echo "‚ùå Aucun conteneur {{.TASK_FILTER}} trouv√© pour le service '$service_full_name'"
        echo ""
        echo "üìã √âtat des t√¢ches pour ce service :"
        docker service ps $service_full_name --format "table {{.Name}}\t{{.Node}}\t{{.DesiredState}}\t{{.CurrentState}}"
        exit 1
      fi

      container_name=$(docker ps --filter "id=$container_id" --format "{{.Names}}")
      echo "‚úÖ Conteneur trouv√© : $container_name ($container_id)"

      # V√©rifier que le script existe dans le conteneur
      echo "üîç V√©rification de l'existence du script '{{.SCRIPT_PATH}}'..."
      if ! docker exec $container_id test -f "{{.SCRIPT_PATH}}"; then
        echo "‚ùå Le script '{{.SCRIPT_PATH}}' n'existe pas dans le conteneur"
        echo ""
        echo "üí° Contenu du r√©pertoire parent :"
        script_dir=$(dirname "{{.SCRIPT_PATH}}")
        docker exec $container_id ls -la "$script_dir" 2>/dev/null || echo "   R√©pertoire '$script_dir' non accessible"
        exit 1
      fi

      # V√©rifier que le script est ex√©cutable
      if ! docker exec $container_id test -x "{{.SCRIPT_PATH}}"; then
        echo "‚ö†Ô∏è  Le script '{{.SCRIPT_PATH}}' n'est pas ex√©cutable"
        echo "üîß Tentative de correction des permissions..."
        docker exec $container_id chmod +x "{{.SCRIPT_PATH}}"
      fi

      # Construire la commande
      command="{{.SCRIPT_PATH}}"
      if [ -n "{{.SCRIPT_ARGS}}" ]; then
        command="$command {{.SCRIPT_ARGS}}"
      fi

      # Ajouter le changement de r√©pertoire si sp√©cifi√©
      if [ -n "{{.WORKING_DIR}}" ]; then
        command="cd {{.WORKING_DIR}} && $command"
      fi

      echo "üöÄ Ex√©cution du script :"
      echo "   üìÑ Script : {{.SCRIPT_PATH}}"
      if [ -n "{{.SCRIPT_ARGS}}" ]; then
        echo "   üìã Arguments : {{.SCRIPT_ARGS}}"
      fi
      if [ -n "{{.WORKING_DIR}}" ]; then
        echo "   üìÅ R√©pertoire : {{.WORKING_DIR}}"
      fi
      echo "   üê≥ Conteneur : $container_name"
      echo ""

      # Ex√©cuter le script
      docker exec $container_id sh -c "$command"
      exit_code=$?

      echo ""
      if [ $exit_code -eq 0 ]; then
        echo "‚úÖ Script ex√©cut√© avec succ√®s"
      else
        echo "‚ùå Le script a √©chou√© avec le code de sortie $exit_code"
        exit $exit_code
      fi
