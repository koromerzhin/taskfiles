version: '3'

tasks:
  deploy:
    desc: "D√©ploie une stack Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      D√©ploie une stack Docker en utilisant docker stack deploy.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose √† utiliser (d√©faut: docker-compose.yml)

      Exemples:
      task docker:stack:deploy
      task docker:stack:deploy STACK_NAME=mon-app
      task docker:stack:deploy STACK_NAME=mon-app COMPOSE_FILE=docker-stack.yml
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        echo "üìÅ Fichiers disponibles :"
        find . -name "docker-*.yml" -o -name "*compose*.yml" 2>/dev/null || echo "   Aucun fichier trouv√©"
        exit 1
      fi

      echo "üöÄ D√©ploiement de la stack '{{.STACK_NAME}}' avec le fichier '{{.COMPOSE_FILE}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' d√©ploy√©e avec succ√®s"

  deploy:with-build:
    desc: "D√©ploie une stack apr√®s avoir construit les images"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      Construit les images puis d√©ploie la stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose (d√©faut: docker-compose.yml)
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        exit 1
      fi

      echo "üî® Construction des images..."
      docker-compose -f {{.COMPOSE_FILE}} build

      echo "üöÄ D√©ploiement de la stack '{{.STACK_NAME}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' construite et d√©ploy√©e"

  update:
    desc: "Met √† jour une stack existante"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    summary: |
      Met √† jour une stack Docker Swarm existante.
      √âquivalent √† docker stack deploy mais avec des messages sp√©cifiques √† la mise √† jour.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMPOSE_FILE: Fichier docker-compose (d√©faut: docker-compose.yml)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üîÑ Mise √† jour de la stack '{{.STACK_NAME}}'..."
      docker stack deploy -c {{.COMPOSE_FILE}} {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' mise √† jour"

  remove:
    desc: "Supprime une stack Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Supprime compl√®tement une stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack √† supprimer (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üóëÔ∏è  Suppression de la stack '{{.STACK_NAME}}'..."
      docker stack rm {{.STACK_NAME}}
      echo "‚úÖ Stack '{{.STACK_NAME}}' supprim√©e"

  list:
    desc: "Liste toutes les stacks Docker Swarm"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: "Affiche la liste de toutes les stacks d√©ploy√©es"
    cmds:
    - echo "üìã Stacks Docker Swarm d√©ploy√©es :"
    - docker stack ls

  services:
    desc: "Liste les services d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Affiche tous les services d'une stack sp√©cifique.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üîß Services de la stack '{{.STACK_NAME}}' :"
      docker stack services {{.STACK_NAME}}

  ps:
    desc: "Affiche les t√¢ches/conteneurs d'une stack"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche toutes les t√¢ches (conteneurs) d'une stack.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
    cmds:
    - |
      if ! docker stack ls --format "{{`{{.Name}}`}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üì¶ T√¢ches de la stack '{{.STACK_NAME}}' :"
      docker stack ps {{.STACK_NAME}}

  logs:
    desc: "Affiche les logs d'un service de la stack"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche les logs d'un service sp√©cifique dans une stack.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SERVICE_NAME: Nom du service (requis)

      Exemple:
      task docker:stack:logs STACK_NAME=mon-app SERVICE_NAME=web
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo "üîß Services disponibles pour la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        exit 1
      fi

      echo "üìÑ Logs du service '{{.STACK_NAME}}_{{.SERVICE_NAME}}' :"
      docker service logs {{.STACK_NAME}}_{{.SERVICE_NAME}} --follow

  validate:
    desc: "Valide un fichier docker-compose pour Docker Swarm"
    silent: true
    vars:
      COMPOSE_FILE: '{{.COMPOSE_FILE | default "docker-compose.yml"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Valide la syntaxe d'un fichier docker-compose avant d√©ploiement.

      Variables:
      - COMPOSE_FILE: Fichier √† valider (d√©faut: docker-compose.yml)
    cmds:
    - |
      if [ ! -f "{{.COMPOSE_FILE}}" ]; then
        echo "‚ùå Le fichier '{{.COMPOSE_FILE}}' n'existe pas"
        exit 1
      fi

      echo "‚úÖ Validation du fichier '{{.COMPOSE_FILE}}'..."
      docker-compose -f {{.COMPOSE_FILE}} config
      echo "‚úÖ Fichier valide"

  check:containers:ready:
    desc: "V√©rifie que les conteneurs sp√©cifi√©s sont pr√™ts"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      V√©rifie que les conteneurs d'une liste sont tous actifs et en bonne sant√©.
      Attend et v√©rifie p√©riodiquement jusqu'√† ce que tous soient pr√™ts ou timeout.

      Variables:
      - CONTAINERS: Liste des conteneurs s√©par√©s par des virgules (ex: "traefik,portainer")
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications en secondes (d√©faut: 10)

      Exemple:
      task docker:stack:check:containers:ready CONTAINERS="traefik,portainer" STACK_NAME=mon-app
    vars:
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      CONTAINERS: '{{.CONTAINERS | default ""}}'
    cmds:
    - |
      if [ -z "{{.CONTAINERS}}" ]; then
        echo "‚ùå CONTAINERS est requis (ex: 'traefik,portainer')"
        exit 1
      fi

      echo "üîç V√©rification de l'√©tat des conteneurs : {{.CONTAINERS}}"
      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle de v√©rification: {{.CHECK_INTERVAL}}s"
      echo ""

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))

      # Convertir la liste en tableau compatible POSIX
      containers_list="{{.CONTAINERS}}"
      containers_clean=$(echo "$containers_list" | tr ',' ' ')

      # Compteur de v√©rifications
      check_count=0

      while true; do
        current_time=$(date +%s)
        check_count=$((check_count + 1))
        
        # V√©rifier le timeout
        if [ $current_time -gt $timeout_time ]; then
          echo ""
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). Tous les conteneurs ne sont pas encore pr√™ts."
          echo "üìã √âtat final des conteneurs :"
          docker ps --filter "name={{.STACK_NAME}}" --format "table {{.Names}}\t{{.Status}}"
          exit 1
        fi
        
        all_ready=true
        ready_containers=""
        missing_containers=""
        
        # V√©rifier chaque conteneur
        for container in $containers_clean; do
          container=$(echo "$container" | xargs)  # Trim whitespace
          
          if docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Names}}" | grep -q "{{.STACK_NAME}}_${container}"; then
            ready_containers="$ready_containers $container"
          else
            missing_containers="$missing_containers $container"
            all_ready=false
          fi
        done
        
        # Affichage de l'√©tat
        elapsed=$((current_time - start_time))
        echo "‚è≥ V√©rification #$check_count (${elapsed}s/{{.TIMEOUT}}s)"
        
        if [ -n "$ready_containers" ]; then
          echo "  ‚úÖ Pr√™ts     :$ready_containers"
        fi
        
        if [ -n "$missing_containers" ]; then
          echo "  ‚è≥ En attente :$missing_containers"
        fi
        
        # Si tous les conteneurs sont pr√™ts, on sort de la boucle
        if [ "$all_ready" = true ]; then
          echo ""
          echo "üéâ Succ√®s ! Tous les conteneurs sont actifs !"
          echo "‚è±Ô∏è  Temps total d'attente : ${elapsed}s"
          echo ""
          echo "üìã Conteneurs actifs :"
          for container in $containers_clean; do
            container=$(echo "$container" | xargs)
            status=$(docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Status}}")
            echo "  ‚úÖ ${container} - $status"
          done
          break
        fi
        
        echo ""
        sleep {{.CHECK_INTERVAL}}
      done

  wait:containers:ready:
    desc: "Attend que les conteneurs sp√©cifi√©s soient pr√™ts"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Attend que tous les conteneurs d'une liste soient actifs et en bonne sant√©.
      Effectue des v√©rifications p√©riodiques jusqu'au timeout.

      Variables:
      - CONTAINERS: Liste des conteneurs s√©par√©s par des virgules (ex: "traefik,portainer")
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications en secondes (d√©faut: 10)

      Exemple:
      task docker:stack:wait:containers:ready CONTAINERS="traefik,portainer" TIMEOUT=600
    vars:
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      CONTAINERS: '{{.CONTAINERS | default ""}}'
    cmds:
    - |
      if [ -z "{{.CONTAINERS}}" ]; then
        echo "‚ùå CONTAINERS est requis (ex: 'traefik,portainer')"
        exit 1
      fi

      echo "‚è≥ Attente que les conteneurs soient pr√™ts : {{.CONTAINERS}}"
      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle de v√©rification: {{.CHECK_INTERVAL}}s"

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))

      # Convertir la liste en format compatible POSIX
      containers_list="{{.CONTAINERS}}"
      containers_clean=$(echo "$containers_list" | tr ',' ' ')

      while true; do
        current_time=$(date +%s)
        
        if [ $current_time -gt $timeout_time ]; then
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). Les conteneurs ne sont pas tous pr√™ts."
          exit 1
        fi
        
        all_ready=true
        
        for container in $containers_clean; do
          container=$(echo "$container" | xargs)  # Trim whitespace
          
          if ! docker ps --filter "name={{.STACK_NAME}}_${container}" --format "{{.Names}}" | grep -q "{{.STACK_NAME}}_${container}"; then
            all_ready=false
            break
          fi
        done
        
        if [ "$all_ready" = true ]; then
          echo "‚úÖ Tous les conteneurs sont pr√™ts!"
          break
        fi
        
        elapsed=$((current_time - start_time))
        echo "‚è≥ Attente... (${elapsed}s/{{.TIMEOUT}}s)"
        sleep {{.CHECK_INTERVAL}}
      done

  check:services:health:
    desc: "V√©rifie la sant√© des services actifs d'une stack (ignore les services Complete)"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
      EXCLUDE_STATES: '{{.EXCLUDE_STATES | default "Complete,Failed,Rejected"}}'
      SPECIFIC_SERVICES: '{{.SPECIFIC_SERVICES | default ""}}'
    summary: |
      V√©rifie que tous les services actifs d'une stack sont en bonne sant√©.
      Ignore automatiquement les services en √©tat Complete, Failed, ou Rejected.
      Si SPECIFIC_SERVICES est d√©fini, v√©rifie uniquement ces services.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications en secondes (d√©faut: 10)
      - EXCLUDE_STATES: √âtats √† ignorer s√©par√©s par des virgules (d√©faut: "Complete,Failed,Rejected")
      - SPECIFIC_SERVICES: Services sp√©cifiques √† v√©rifier, s√©par√©s par des virgules (d√©faut: tous)

      Exemples:
      task docker:stack:check:services:health STACK_NAME=lampy
      task docker:stack:check:services:health STACK_NAME=lampy SPECIFIC_SERVICES="mercure,redis,traefik"
      task docker:stack:check:services:health STACK_NAME=production TIMEOUT=600
      task docker:stack:check:services:health STACK_NAME=dev EXCLUDE_STATES="Complete,Shutdown"
    cmds:
    - |
      # V√©rifier que la stack existe
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi

      echo "üîç V√©rification de la sant√© des services de la stack '{{.STACK_NAME}}'..."

      # D√©terminer quels services v√©rifier
      if [ -n "{{.SPECIFIC_SERVICES}}" ]; then
        echo "üéØ Services cibl√©s : {{.SPECIFIC_SERVICES}}"
        check_mode="specific"
        target_services=$(echo "{{.SPECIFIC_SERVICES}}" | tr ',' ' ')
      else
        echo "üåê Mode : Tous les services actifs"
        check_mode="all"
      fi

      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle de v√©rification: {{.CHECK_INTERVAL}}s"
      echo "üö´ √âtats ignor√©s: {{.EXCLUDE_STATES}}"
      echo ""

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))
      check_count=0

      # Convertir les √©tats √† exclure en format utilisable
      exclude_states="{{.EXCLUDE_STATES}}"
      exclude_pattern=$(echo "$exclude_states" | tr ',' '|')

      while true; do
        current_time=$(date +%s)
        check_count=$((check_count + 1))
        
        # V√©rifier le timeout
        if [ $current_time -gt $timeout_time ]; then
          echo ""
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). Tous les services ne sont pas encore en bonne sant√©."
          echo ""
          echo "üìã √âtat final de tous les services :"
          docker service ls --filter "label=com.docker.stack.namespace={{.STACK_NAME}}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
          echo ""
          echo "üìã √âtat d√©taill√© des t√¢ches :"
          docker stack ps {{.STACK_NAME}} --format "table {{.Name}}\t{{.CurrentState}}\t{{.DesiredState}}\t{{.Error}}"
          exit 1
        fi
        
        # Compter les services selon leur √©tat
        running_count=0
        excluded_count=0
        pending_count=0
        error_count=0
        expected_running=0
        
        service_details=""
        excluded_services=""
        pending_services=""
        error_services=""

        if [ "$check_mode" = "specific" ]; then
          # Mode sp√©cifique : v√©rifier uniquement les services demand√©s
          for service_short_name in $target_services; do
            service_short_name=$(echo "$service_short_name" | xargs)  # Trim whitespace
            service_full_name="{{.STACK_NAME}}_${service_short_name}"
            
            # V√©rifier que le service existe
            if ! docker service ls --filter "name=$service_full_name" --format "{{.Name}}" | grep -q "^$service_full_name$"; then
              echo "‚ùå Service '$service_full_name' non trouv√© dans la stack"
              continue
            fi
            
            expected_running=$((expected_running + 1))
            
            # Obtenir l'√©tat des t√¢ches pour ce service
            task_states=$(docker service ps $service_full_name --format "{{.CurrentState}}" --no-trunc)
            replicas=$(docker service ls --filter "name=$service_full_name" --format "{{.Replicas}}")
            
            # V√©rifier si le service a des t√¢ches dans les √©tats √† exclure
            if echo "$task_states" | grep -E "($exclude_pattern)" >/dev/null 2>&1; then
              excluded_count=$((excluded_count + 1))
              excluded_services="$excluded_services $service_short_name"
              expected_running=$((expected_running - 1))
              continue
            fi
            
            # V√©rifier si le service est en cours d'ex√©cution (Running)
            if echo "$task_states" | grep -q "Running" && [ "$replicas" != "0/1" ] && [ "$replicas" != "0/0" ]; then
              running_count=$((running_count + 1))
              service_details="$service_details $service_short_name"
            else
              # V√©rifier s'il y a des erreurs
              if docker service ps $service_full_name --format "{{.Error}}" | grep -v "^$" >/dev/null 2>&1; then
                error_count=$((error_count + 1))
                error_services="$error_services $service_short_name"
              else
                pending_count=$((pending_count + 1))
                pending_services="$pending_services $service_short_name"
              fi
            fi
          done
        else
          # Mode tous les services : analyser tous les services de la stack
          total_services=$(docker service ls --filter "label=com.docker.stack.namespace={{.STACK_NAME}}" --format "{{.Name}}" | wc -l)
          
          if [ $total_services -eq 0 ]; then
            echo "‚ùå Aucun service trouv√© dans la stack '{{.STACK_NAME}}'"
            exit 1
          fi

          # Analyser chaque service
          for service_name in $(docker service ls --filter "label=com.docker.stack.namespace={{.STACK_NAME}}" --format "{{.Name}}"); do
            # Obtenir les informations d√©taill√©es du service
            replicas=$(docker service ls --filter "name=$service_name" --format "{{.Replicas}}")
            
            # Obtenir l'√©tat des t√¢ches pour ce service
            task_states=$(docker service ps $service_name --format "{{.CurrentState}}" --no-trunc)
            
            # Analyser l'√©tat du service
            service_short_name=$(echo "$service_name" | sed "s/^{{.STACK_NAME}}_//")
            
            # V√©rifier si le service a des t√¢ches dans les √©tats √† exclure
            if echo "$task_states" | grep -E "($exclude_pattern)" >/dev/null 2>&1; then
              excluded_count=$((excluded_count + 1))
              excluded_services="$excluded_services $service_short_name"
              continue
            fi
            
            expected_running=$((expected_running + 1))
            
            # V√©rifier si le service est en cours d'ex√©cution (Running)
            if echo "$task_states" | grep -q "Running" && [ "$replicas" != "0/1" ] && [ "$replicas" != "0/0" ]; then
              running_count=$((running_count + 1))
              service_details="$service_details $service_short_name"
            else
              # V√©rifier s'il y a des erreurs
              if docker service ps $service_name --format "{{.Error}}" | grep -v "^$" >/dev/null 2>&1; then
                error_count=$((error_count + 1))
                error_services="$error_services $service_short_name"
              else
                pending_count=$((pending_count + 1))
                pending_services="$pending_services $service_short_name"
              fi
            fi
          done
        fi
        
        # Affichage de l'√©tat
        elapsed=$((current_time - start_time))
        echo "‚è≥ V√©rification #$check_count (${elapsed}s/{{.TIMEOUT}}s)"
        
        if [ "$check_mode" = "specific" ]; then
          echo "   üéØ Services cibl√©s: $(echo "{{.SPECIFIC_SERVICES}}" | tr ',' ' ' | wc -w) | Actifs attendus: $expected_running"
        else
          total_services_in_stack=$(docker service ls --filter "label=com.docker.stack.namespace={{.STACK_NAME}}" --format "{{.Name}}" | wc -l)
          echo "   üìä Total: $total_services_in_stack services | Actifs attendus: $expected_running"
        fi
        
        if [ $running_count -gt 0 ]; then
          echo "   ‚úÖ En cours ($running_count/$expected_running):$service_details"
        fi
        
        if [ $excluded_count -gt 0 ]; then
          echo "   üö´ Ignor√©s ($excluded_count):$excluded_services"
        fi
        
        if [ $pending_count -gt 0 ]; then
          echo "   ‚è≥ En attente ($pending_count):$pending_services"
        fi
        
        if [ $error_count -gt 0 ]; then
          echo "   ‚ùå En erreur ($error_count):$error_services"
        fi
        
        # V√©rifier si tous les services attendus sont en cours
        if [ $running_count -eq $expected_running ] && [ $error_count -eq 0 ]; then
          echo ""
          echo "üéâ Succ√®s ! Tous les services cibl√©s sont en bonne sant√© !"
          echo "‚è±Ô∏è  Temps total d'attente : ${elapsed}s"
          echo ""
          echo "üìã R√©sum√© final :"
          echo "   ‚úÖ Services en cours : $running_count/$expected_running"
          if [ $excluded_count -gt 0 ]; then
            echo "   üö´ Services ignor√©s : $excluded_count"
          fi
          echo ""
          echo "üìã Services v√©rifi√©s :"
          
          if [ "$check_mode" = "specific" ]; then
            # Afficher uniquement les services sp√©cifi√©s
            for service_short_name in $target_services; do
              service_short_name=$(echo "$service_short_name" | xargs)
              service_full_name="{{.STACK_NAME}}_${service_short_name}"
              
              if docker service ls --filter "name=$service_full_name" --format "{{.Name}}" | grep -q "^$service_full_name$"; then
                replicas=$(docker service ls --filter "name=$service_full_name" --format "{{.Replicas}}")
                task_state=$(docker service ps $service_full_name --format "{{.CurrentState}}" --no-trunc | head -n 1)
                
                # Ignorer les services exclus dans l'affichage
                if echo "$task_state" | grep -E "($exclude_pattern)" >/dev/null 2>&1; then
                  echo "   üö´ $service_short_name - $task_state (ignor√©)"
                else
                  echo "   ‚úÖ $service_short_name - $task_state ($replicas)"
                fi
              else
                echo "   ‚ùì $service_short_name - Service non trouv√©"
              fi
            done
          else
            # Afficher tous les services de la stack
            for service_name in $(docker service ls --filter "label=com.docker.stack.namespace={{.STACK_NAME}}" --format "{{.Name}}"); do
              replicas=$(docker service ls --filter "name=$service_name" --format "{{.Replicas}}")
              task_state=$(docker service ps $service_name --format "{{.CurrentState}}" --no-trunc | head -n 1)
              service_short_name=$(echo "$service_name" | sed "s/^{{.STACK_NAME}}_//")
              
              # Ignorer les services exclus
              if echo "$task_state" | grep -E "($exclude_pattern)" >/dev/null 2>&1; then
                echo "   üö´ $service_short_name - $task_state (ignor√©)"
              else
                echo "   ‚úÖ $service_short_name - $task_state ($replicas)"
              fi
            done
          fi
          break
        fi
        
        echo ""
        sleep {{.CHECK_INTERVAL}}
      done

  exec:
    desc: "Ex√©cute une commande dans un conteneur d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
      COMMAND: '{{.COMMAND | default "sh"}}'
      TASK_FILTER: '{{.TASK_FILTER | default "running"}}'
      INTERACTIVE: '{{.INTERACTIVE | default "true"}}'
    summary: |
      Ex√©cute une commande dans un conteneur appartenant √† une stack Docker Swarm.

      Variables requises:
      - SERVICE_NAME: Nom du service dans la stack (ex: "web", "api", "database")

      Variables optionnelles:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - COMMAND: Commande √† ex√©cuter (d√©faut: sh)
      - TASK_FILTER: Filtre pour les t√¢ches (d√©faut: running)
      - INTERACTIVE: Mode interactif (d√©faut: true)

      Exemples:
      task docker:stack:exec SERVICE_NAME=web
      task docker:stack:exec SERVICE_NAME=web COMMAND="ls -la"
      task docker:stack:exec SERVICE_NAME=api COMMAND="/app/scripts/migrate.sh"
      task docker:stack:exec SERVICE_NAME=database COMMAND="mysql -u root -p" INTERACTIVE=true
      task docker:stack:exec STACK_NAME=production SERVICE_NAME=worker COMMAND="python manage.py migrate"
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        if docker stack ls --format "{{.Name}}" | grep -q "^{{.STACK_NAME}}$"; then
          docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        else
          echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
          echo "üìã Stacks disponibles :"
          docker stack ls --format "{{.Name}}"
        fi
        exit 1
      fi

      # V√©rifier que la stack existe
      echo "üîç V√©rification de l'existence de la stack '{{.STACK_NAME}}'..."
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi
      echo "‚úÖ Stack '{{.STACK_NAME}}' trouv√©e"

      service_full_name="{{.STACK_NAME}}_{{.SERVICE_NAME}}"

      # V√©rifier que le service existe
      echo "üîç V√©rification de l'existence du service '$service_full_name'..."
      if ! docker service ls | awk 'NR>1 {print $2}' | grep -q "^$service_full_name$"; then
        echo "‚ùå Le service '$service_full_name' n'existe pas"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} | awk 'NR>1 {print $2}'
        exit 1
      fi
      echo "‚úÖ Service '$service_full_name' trouv√©"

      # Trouver le conteneur actif pour ce service
      echo "üîç Recherche d'un conteneur actif pour le service '$service_full_name'..."

      container_id=$(docker ps | grep "$service_full_name" | awk '{print $1}' | head -n 1)

      if [ -z "$container_id" ]; then
        echo "‚ùå Aucun conteneur actif trouv√© pour le service '$service_full_name'"
        echo ""
        echo "üìã √âtat des t√¢ches pour ce service :"
        docker service ps $service_full_name
        exit 1
      fi

      container_name=$(docker ps | grep "$container_id" | awk '{print $NF}')
      echo "‚úÖ Conteneur trouv√© : $container_name ($container_id)"
      echo "üöÄ Ex√©cution de la commande : {{.COMMAND}}"
      echo ""

      # Pr√©parer les options Docker exec
      docker_options=""
      # V√©rifier si on est dans un environnement CI/CD o√π TTY n'est pas disponible
      if [ "${DOCKER_INTERACTIVE:-true}" = "false" ] || [ "${CI:-false}" = "true" ] || [ "${GITHUB_ACTIONS:-false}" = "true" ]; then
        # En CI/CD, ne pas utiliser le mode interactif
        docker_options=""
      elif [ "{{.INTERACTIVE}}" = "true" ]; then
        docker_options="-it"
      fi      # Ex√©cuter la commande
      docker exec $docker_options $container_id {{.COMMAND}}

  shell:
    desc: "Acc√®de au shell (bash ou sh) d'un conteneur dans une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
      SHELL_TYPE: '{{.SHELL_TYPE | default "auto"}}'
      EXEC_USER: '{{.EXEC_USER | default ""}}'
    summary: |
      Acc√®de au shell interactif (bash ou sh) d'un conteneur appartenant √† une stack Docker Swarm.
      D√©tecte automatiquement le shell disponible (bash prioritaire, sinon sh).

      Variables requises:
      - SERVICE_NAME: Nom du service dans la stack (ex: "web", "api", "database")

      Variables optionnelles:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SHELL_TYPE: Type de shell √† utiliser - "bash", "sh", "auto" (d√©faut: auto)
      - EXEC_USER: Utilisateur pour l'ex√©cution (d√©faut: utilisateur par d√©faut du conteneur)

      Exemples:
      task docker:stack:shell SERVICE_NAME=web
      task docker:stack:shell SERVICE_NAME=api SHELL_TYPE=bash
      task docker:stack:shell SERVICE_NAME=database EXEC_USER=root
      task docker:stack:shell STACK_NAME=production SERVICE_NAME=worker SHELL_TYPE=sh
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        if docker stack ls --format "{{.Name}}" | grep -q "^{{.STACK_NAME}}$"; then
          docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        else
          echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
          echo "üìã Stacks disponibles :"
          docker stack ls --format "{{.Name}}"
        fi
        exit 1
      fi

      # V√©rifier que la stack existe
      echo "üîç V√©rification de l'existence de la stack '{{.STACK_NAME}}'..."
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi
      echo "‚úÖ Stack '{{.STACK_NAME}}' trouv√©e"

      service_full_name="{{.STACK_NAME}}_{{.SERVICE_NAME}}"

      # V√©rifier que le service existe
      echo "üîç V√©rification de l'existence du service '$service_full_name'..."
      if ! docker service ls | awk 'NR>1 {print $2}' | grep -q "^$service_full_name$"; then
        echo "‚ùå Le service '$service_full_name' n'existe pas"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} | awk 'NR>1 {print $2}'
        exit 1
      fi
      echo "‚úÖ Service '$service_full_name' trouv√©"

      # Trouver le conteneur actif pour ce service
      echo "üîç Recherche d'un conteneur actif pour le service '$service_full_name'..."

      container_id=$(docker ps | grep "$service_full_name" | awk '{print $1}' | head -n 1)

      if [ -z "$container_id" ]; then
        echo "‚ùå Aucun conteneur actif trouv√© pour le service '$service_full_name'"
        echo ""
        echo "üìã √âtat des t√¢ches pour ce service :"
        docker service ps $service_full_name
        exit 1
      fi

      container_name=$(docker ps | grep "$container_id" | awk '{print $NF}')
      echo "‚úÖ Conteneur trouv√© : $container_name ($container_id)"

      # D√©terminer le shell √† utiliser
      shell_command=""
      shell_type="{{.SHELL_TYPE}}"

      if [ "$shell_type" = "auto" ]; then
        echo "üîç D√©tection automatique du shell disponible..."
        
        # Tester bash en premier
        if docker exec $container_id which bash >/dev/null 2>&1; then
          shell_command="bash"
          echo "‚úÖ Bash d√©tect√© et disponible"
        elif docker exec $container_id which sh >/dev/null 2>&1; then
          shell_command="sh"
          echo "‚úÖ Shell sh d√©tect√© et disponible"
        else
          echo "‚ùå Aucun shell compatible trouv√© (bash/sh)"
          echo "üí° Shells disponibles dans le conteneur :"
          docker exec $container_id ls -la /bin/*sh 2>/dev/null || echo "   Aucun shell trouv√© dans /bin/"
          exit 1
        fi
      else
        shell_command="$shell_type"
        echo "üîß Shell sp√©cifi√© : $shell_command"
        
        # V√©rifier que le shell sp√©cifi√© existe
        if ! docker exec $container_id which $shell_command >/dev/null 2>&1; then
          echo "‚ùå Shell '$shell_command' non disponible dans le conteneur"
          echo "üí° Shells disponibles :"
          docker exec $container_id ls -la /bin/*sh 2>/dev/null || echo "   Aucun shell trouv√© dans /bin/"
          exit 1
        fi
      fi

      # Pr√©parer les options pour docker exec
      docker_options=""
      # V√©rifier si on est dans un environnement CI/CD o√π TTY n'est pas disponible
      if [ "${DOCKER_INTERACTIVE:-true}" = "false" ] || [ "${CI:-false}" = "true" ] || [ "${GITHUB_ACTIONS:-false}" = "true" ]; then
        # En CI/CD, ne pas utiliser le mode interactif
        docker_options=""
        echo "‚ö†Ô∏è  Mode non-interactif d√©tect√© (CI/CD)"
      else
        # En environnement normal, utiliser le mode interactif pour shell
        docker_options="-it"
      fi      # Ajouter l'utilisateur si sp√©cifi√©
      if [ -n "{{.EXEC_USER}}" ]; then
        docker_options="$docker_options --user {{.EXEC_USER}}"
        echo "üë§ Utilisateur : {{.EXEC_USER}}"
      fi

      echo ""
      echo "üêö Ouverture du shell interactif..."
      echo "   üê≥ Conteneur : $container_name ($container_id)"
      echo "   üêö Shell : $shell_command"
      echo "   ‚å®Ô∏è  Mode : Interactif"
      echo ""
      echo "üí° Tapez 'exit' pour quitter le shell"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      echo ""

      # Lancer le shell interactif
      docker exec $docker_options $container_id $shell_command

  exec:script:
    desc: "Ex√©cute un script dans un conteneur d'une stack"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      SERVICE_NAME: '{{.SERVICE_NAME | default ""}}'
      SCRIPT_PATH: '{{.SCRIPT_PATH | default ""}}'
      SCRIPT_ARGS: '{{.SCRIPT_ARGS | default ""}}'
      TASK_FILTER: '{{.TASK_FILTER | default "running"}}'
      WORKING_DIR: '{{.WORKING_DIR | default ""}}'
    summary: |
      Ex√©cute un script sp√©cifique dans un conteneur appartenant √† une stack Docker Swarm.

      Variables requises:
      - SERVICE_NAME: Nom du service dans la stack (ex: "web", "api", "database")  
      - SCRIPT_PATH: Chemin du script √† ex√©cuter dans le conteneur

      Variables optionnelles:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - SCRIPT_ARGS: Arguments √† passer au script (d√©faut: "")
      - TASK_FILTER: Filtre pour les t√¢ches (d√©faut: running)
      - WORKING_DIR: R√©pertoire de travail dans le conteneur (d√©faut: r√©pertoire courant du conteneur)

      Exemples:
      task docker:stack:exec:script SERVICE_NAME=web SCRIPT_PATH="/app/scripts/deploy.sh"
      task docker:stack:exec:script SERVICE_NAME=api SCRIPT_PATH="/app/migrate.py" SCRIPT_ARGS="--force"
      task docker:stack:exec:script SERVICE_NAME=worker SCRIPT_PATH="/scripts/backup.sh" WORKING_DIR="/data"
      task docker:stack:exec:script STACK_NAME=production SERVICE_NAME=app SCRIPT_PATH="/opt/scripts/maintenance.sh" SCRIPT_ARGS="--mode full"
    cmds:
    - |
      if [ -z "{{.SERVICE_NAME}}" ]; then
        echo "‚ùå SERVICE_NAME est requis"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        if docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
          docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        else
          echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        fi
        exit 1
      fi

      if [ -z "{{.SCRIPT_PATH}}" ]; then
        echo "‚ùå SCRIPT_PATH est requis"
        echo "üí° Exemple: SCRIPT_PATH=/app/scripts/deploy.sh"
        exit 1
      fi

      # V√©rifier que la stack existe
      if ! docker stack ls | awk 'NR>1 {print $1}' | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls | awk 'NR>1 {print $1}'
        exit 1
      fi

      service_full_name="{{.STACK_NAME}}_{{.SERVICE_NAME}}"

      # V√©rifier que le service existe
      if ! docker service ls --filter "name=$service_full_name" --format "{{.Name}}" | grep -q "^$service_full_name$"; then
        echo "‚ùå Le service '$service_full_name' n'existe pas"
        echo ""
        echo "üîß Services disponibles dans la stack '{{.STACK_NAME}}' :"
        docker stack services {{.STACK_NAME}} --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
        exit 1
      fi

      # Trouver le conteneur actif pour ce service
      echo "üîç Recherche d'un conteneur actif pour le service '$service_full_name'..."

      container_id=$(docker ps --filter "label=com.docker.swarm.service.name=$service_full_name" --filter "status={{.TASK_FILTER}}" --format "{{.ID}}" | head -n 1)

      if [ -z "$container_id" ]; then
        echo "‚ùå Aucun conteneur {{.TASK_FILTER}} trouv√© pour le service '$service_full_name'"
        echo ""
        echo "üìã √âtat des t√¢ches pour ce service :"
        docker service ps $service_full_name --format "table {{.Name}}\t{{.Node}}\t{{.DesiredState}}\t{{.CurrentState}}"
        exit 1
      fi

      container_name=$(docker ps --filter "id=$container_id" --format "{{.Names}}")
      echo "‚úÖ Conteneur trouv√© : $container_name ($container_id)"

      # V√©rifier que le script existe dans le conteneur
      echo "üîç V√©rification de l'existence du script '{{.SCRIPT_PATH}}'..."
      if ! docker exec $container_id test -f "{{.SCRIPT_PATH}}"; then
        echo "‚ùå Le script '{{.SCRIPT_PATH}}' n'existe pas dans le conteneur"
        echo ""
        echo "üí° Contenu du r√©pertoire parent :"
        script_dir=$(dirname "{{.SCRIPT_PATH}}")
        docker exec $container_id ls -la "$script_dir" 2>/dev/null || echo "   R√©pertoire '$script_dir' non accessible"
        exit 1
      fi

      # V√©rifier que le script est ex√©cutable
      if ! docker exec $container_id test -x "{{.SCRIPT_PATH}}"; then
        echo "‚ö†Ô∏è  Le script '{{.SCRIPT_PATH}}' n'est pas ex√©cutable"
        echo "üîß Tentative de correction des permissions..."
        docker exec $container_id chmod +x "{{.SCRIPT_PATH}}"
      fi

      # Construire la commande
      command="{{.SCRIPT_PATH}}"
      if [ -n "{{.SCRIPT_ARGS}}" ]; then
        command="$command {{.SCRIPT_ARGS}}"
      fi

      # Ajouter le changement de r√©pertoire si sp√©cifi√©
      if [ -n "{{.WORKING_DIR}}" ]; then
        command="cd {{.WORKING_DIR}} && $command"
      fi

      echo "üöÄ Ex√©cution du script :"
      echo "   üìÑ Script : {{.SCRIPT_PATH}}"
      if [ -n "{{.SCRIPT_ARGS}}" ]; then
        echo "   üìã Arguments : {{.SCRIPT_ARGS}}"
      fi
      if [ -n "{{.WORKING_DIR}}" ]; then
        echo "   üìÅ R√©pertoire : {{.WORKING_DIR}}"
      fi
      echo "   üê≥ Conteneur : $container_name"
      echo ""

      # Ex√©cuter le script
      docker exec $container_id sh -c "$command"
      exit_code=$?

      echo ""
      if [ $exit_code -eq 0 ]; then
        echo "‚úÖ Script ex√©cut√© avec succ√®s"
      else
        echo "‚ùå Le script a √©chou√© avec le code de sortie $exit_code"
        exit $exit_code
      fi
