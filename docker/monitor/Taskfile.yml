version: '3'

# Taskfile pour le monitoring Docker - Surveillance et diagnostics

includes:
  container:
    taskfile: ./container/Taskfile.yml
    dir: ./container

tasks:
  events:
    desc: "Surveille tous les √©v√©nements Docker"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche tous les √©v√©nements Docker en temps r√©el (start, stop, create, destroy, etc.).

      Variables:
      - IMAGE_NAME: Filtrer par image (optionnel)
      - EVENT_TYPE: Type d'√©v√©nement (start, stop, create, destroy, etc.)

      Exemples:
      task docker:monitor:events
      task docker:monitor:events EVENT_TYPE=start
      task docker:monitor:events IMAGE_NAME=nginx EVENT_TYPE=start
    vars:
      EVENT_TYPE: '{{.EVENT_TYPE | default ""}}'
      IMAGE_NAME: '{{.IMAGE_NAME | default ""}}'
    cmds:
    - |
      echo "üì° Surveillance des √©v√©nements Docker en temps r√©el..."
      echo "   Appuyez sur Ctrl+C pour arr√™ter"
      echo ""

      filters="--filter container"

      if [ -n "{{.IMAGE_NAME}}" ]; then
        filters="$filters --filter image={{.IMAGE_NAME}}"
        echo "üéØ Filtrage pour l'image: {{.IMAGE_NAME}}"
      fi

      if [ -n "{{.EVENT_TYPE}}" ]; then
        filters="$filters --filter event={{.EVENT_TYPE}}"
        echo "üéØ Filtrage pour l'√©v√©nement: {{.EVENT_TYPE}}"
      fi

      echo ""
      docker events $filters --format "{{{{.Time}}}} - {{{{.Action}}}} - {{{{.Actor.Attributes.name}}}} ({{{{.Actor.Attributes.image}}}})"

  stack:health:
    desc: "V√©rifie la sant√© globale d'une stack Docker"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
    summary: |
      Affiche un rapport de sant√© complet d'une stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)

      Exemple:
      task docker:monitor:stack:health STACK_NAME=production
    cmds:
    - |
      if ! docker stack ls --format "{{{{.Name}}}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üè• Rapport de sant√© de la stack '{{.STACK_NAME}}' :"
      echo ""

      echo "üîß Services :"
      docker stack services {{.STACK_NAME}} --format "table {{{{.Name}}}}\t{{{{.Replicas}}}}\t{{{{.Image}}}}"

      echo ""
      echo "üì¶ T√¢ches/Conteneurs :"
      docker stack ps {{.STACK_NAME}} --format "table {{{{.Name}}}}\t{{{{.Node}}}}\t{{{{.DesiredState}}}}\t{{{{.CurrentState}}}}"

      echo ""
      echo "üîç Analyse d√©taill√©e :"

      # Compter les services en bonne sant√©
      running_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.CurrentState}}}}" | grep -c "Running" || echo "0")
      total_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.Name}}}}" | wc -l)

      echo "  üìä T√¢ches en cours : $running_tasks/$total_tasks"

      if [ "$running_tasks" -eq "$total_tasks" ] && [ "$total_tasks" -gt 0 ]; then
        echo "  ‚úÖ Tous les services sont op√©rationnels"
      else
        echo "  ‚ö†Ô∏è  Certains services ne sont pas op√©rationnels"
        echo "  üîç Services probl√©matiques :"
        docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "table {{{{.Name}}}}\t{{{{.CurrentState}}}}" | grep -v "Running"
      fi

  wait:stack:ready:
    desc: "Attend qu'une stack soit compl√®tement d√©ploy√©e"
    silent: true
    vars:
      STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
      TIMEOUT: '{{.TIMEOUT | default "300"}}'
      CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Attend que tous les services d'une stack soient dans l'√©tat "Running".

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications (d√©faut: 10)

      Exemple:
      task docker:monitor:wait:stack:ready STACK_NAME=production TIMEOUT=600
    cmds:
    - |
      if ! docker stack ls --format "{{{{.Name}}}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        exit 1
      fi

      echo "‚è≥ Attente que la stack '{{.STACK_NAME}}' soit pr√™te..."
      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle: {{.CHECK_INTERVAL}}s"
      echo ""

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))

      while true; do
        current_time=$(date +%s)
        
        if [ $current_time -gt $timeout_time ]; then
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). La stack n'est pas compl√®tement pr√™te."
          echo "üìä √âtat actuel :"
          docker stack ps {{.STACK_NAME}} --format "table {{{{.Name}}}}\t{{{{.CurrentState}}}}\t{{{{.Error}}}}"
          exit 1
        fi
        
        # Compter les t√¢ches en cours d'ex√©cution
        running_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.CurrentState}}}}" | grep -c "Running" || echo "0")
        total_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.Name}}}}" | wc -l)
        
        elapsed=$((current_time - start_time))
        echo "‚è≥ Progression: $running_tasks/$total_tasks t√¢ches pr√™tes (${elapsed}s/{{.TIMEOUT}}s)"
        
        if [ "$running_tasks" -eq "$total_tasks" ] && [ "$total_tasks" -gt 0 ]; then
          echo "‚úÖ Stack '{{.STACK_NAME}}' compl√®tement pr√™te!"
          break
        fi
        
        # Afficher les services qui ne sont pas encore pr√™ts
        echo "üîç Services en attente :"
        docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "table {{{{.Name}}}}\t{{{{.CurrentState}}}}" | grep -v "Running" | head -3
        echo ""
        
        sleep {{.CHECK_INTERVAL}}
      done

  events:filtered:
    desc: "Surveille les √©v√©nements Docker avec filtres avanc√©s"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Surveille les √©v√©nements Docker avec des filtres personnalis√©s.

      Variables:
      - STACK_NAME: Filtrer par stack (optionnel)
      - EVENT_TYPES: Types d'√©v√©nements (start,stop,die,health_status, etc.)
      - SINCE: Depuis quand (ex: "2h", "2023-01-01T00:00:00")

      Exemple:
      task docker:monitor:events:filtered STACK_NAME=production EVENT_TYPES="start,stop,die"
    vars:
      EVENT_TYPES: '{{.EVENT_TYPES | default "start,stop,die,health_status"}}'
      SINCE: '{{.SINCE | default "1h"}}'
      STACK_NAME: '{{.STACK_NAME | default ""}}'
    cmds:
    - |
      echo "üì° Surveillance des √©v√©nements Docker..."
      echo "üéØ Filtres :"
      echo "   Types d'√©v√©nements: {{.EVENT_TYPES}}"
      echo "   Depuis: {{.SINCE}}"
      if [ -n "{{.STACK_NAME}}" ]; then
        echo "   Stack: {{.STACK_NAME}}"
      fi
      echo ""
      echo "‚èπÔ∏è  Appuyez sur Ctrl+C pour arr√™ter"
      echo ""

      # Construire les filtres
      filters="--since {{.SINCE}}"

      # Ajouter les filtres d'√©v√©nements
      IFS=',' read -ra EVENT_ARRAY <<< "{{.EVENT_TYPES}}"
      for event in "${EVENT_ARRAY[@]}"; do
        event=$(echo "$event" | xargs)  # Trim whitespace
        filters="$filters --filter event=$event"
      done

      # Ajouter le filtre de stack si sp√©cifi√©
      if [ -n "{{.STACK_NAME}}" ]; then
        filters="$filters --filter label=com.docker.stack.namespace={{.STACK_NAME}}"
      fi

      echo "üîç Commande: docker events $filters"
      echo ""

      docker events $filters --format "{{{{.Time}}}} [{{{{.Action}}}}] {{{{.Actor.Attributes.name}}}} ({{{{.Actor.Attributes.image}}}})"
