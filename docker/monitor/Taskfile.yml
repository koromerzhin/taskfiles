version: '3'

# Taskfile pour le monitoring Docker - Surveillance et diagnostics

vars:
  IMAGE_NAME: '{{.IMAGE_NAME | default ""}}'
  CONTAINER_NAME: '{{.CONTAINER_NAME | default ""}}'
  CONTAINERS: '{{.CONTAINERS | default ""}}'
  STACK_NAME: '{{.STACK_NAME | default "taskfiles-stack"}}'
  TIMEOUT: '{{.TIMEOUT | default "300"}}'
  CHECK_INTERVAL: '{{.CHECK_INTERVAL | default "10"}}'
  LOG_LEVEL: '{{.LOG_LEVEL | default "INFO"}}'

tasks:
  container:start:
    desc: "Surveille le lancement de conteneurs en temps r√©el"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Surveille les √©v√©nements Docker pour d√©tecter le lancement de conteneurs.
      Affiche quand une image est lanc√©e avec l'horodatage.

      Variables:
      - IMAGE_NAME: Filtrer par nom d'image sp√©cifique (optionnel)

      Exemples:
      task docker:monitor:container:start
      task docker:monitor:container:start IMAGE_NAME=nginx
    cmds:
    - |
      echo "üîç Surveillance des lancements de conteneurs en temps r√©el..."
      echo "   Appuyez sur Ctrl+C pour arr√™ter"
      echo ""

      if [ -n "{{.IMAGE_NAME}}" ]; then
        echo "üéØ Filtrage pour l'image: {{.IMAGE_NAME}}"
        docker events --filter container --filter event=start --filter image={{.IMAGE_NAME}} --format "{{{{.TimeNano}}}} - üöÄ Container {{{{.Actor.Attributes.name}}}} ({{{{.Actor.Attributes.image}}}}) started"
      else
        docker events --filter container --filter event=start --format "{{{{.TimeNano}}}} - üöÄ Container {{{{.Actor.Attributes.name}}}} ({{{{.Actor.Attributes.image}}}}) started"
      fi

  events:
    desc: "Surveille tous les √©v√©nements Docker"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche tous les √©v√©nements Docker en temps r√©el (start, stop, create, destroy, etc.).

      Variables:
      - IMAGE_NAME: Filtrer par image (optionnel)
      - EVENT_TYPE: Type d'√©v√©nement (start, stop, create, destroy, etc.)

      Exemples:
      task docker:monitor:events
      task docker:monitor:events EVENT_TYPE=start
      task docker:monitor:events IMAGE_NAME=nginx EVENT_TYPE=start
    cmds:
    - |
      echo "üì° Surveillance des √©v√©nements Docker en temps r√©el..."
      echo "   Appuyez sur Ctrl+C pour arr√™ter"
      echo ""

      filters="--filter container"

      if [ -n "{{.IMAGE_NAME}}" ]; then
        filters="$filters --filter image={{.IMAGE_NAME}}"
        echo "üéØ Filtrage pour l'image: {{.IMAGE_NAME}}"
      fi

      if [ -n "{{.EVENT_TYPE}}" ]; then
        filters="$filters --filter event={{.EVENT_TYPE}}"
        echo "üéØ Filtrage pour l'√©v√©nement: {{.EVENT_TYPE}}"
      fi

      echo ""
      docker events $filters --format "{{{{.Time}}}} - {{{{.Action}}}} - {{{{.Actor.Attributes.name}}}} ({{{{.Actor.Attributes.image}}}})"

  container:status:
    desc: "V√©rifie le statut d'un conteneur sp√©cifique"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche le statut d√©taill√© d'un conteneur.

      Variables:
      - CONTAINER_NAME: Nom du conteneur (requis)

      Exemple:
      task docker:monitor:container:status CONTAINER_NAME=mon-conteneur
    cmds:
    - |
      if [ -z "{{.CONTAINER_NAME}}" ]; then
        echo "‚ùå CONTAINER_NAME est requis"
        echo "üìã Conteneurs disponibles :"
        docker ps -a --format "table {{{{.Names}}}}\t{{{{.Image}}}}\t{{{{.Status}}}}"
        exit 1
      fi

      echo "üîç Statut du conteneur '{{.CONTAINER_NAME}}' :"
      echo ""

      # V√©rifier si le conteneur existe
      if ! docker ps -a --filter "name={{.CONTAINER_NAME}}" --format "{{{{.Names}}}}" | grep -q "^{{.CONTAINER_NAME}}$"; then
        echo "‚ùå Le conteneur '{{.CONTAINER_NAME}}' n'existe pas"
        exit 1
      fi

      # Informations de base
      echo "üìä Informations g√©n√©rales :"
      docker ps -a --filter "name={{.CONTAINER_NAME}}" --format "table {{{{.Names}}}}\t{{{{.Image}}}}\t{{{{.Status}}}}\t{{{{.Ports}}}}"

      echo ""
      echo "üè• √âtat de sant√© :"
      health_status=$(docker inspect {{.CONTAINER_NAME}} --format='{{{{.State.Health.Status}}}}' 2>/dev/null || echo "no-healthcheck")

      case $health_status in
        "healthy")
          echo "  ‚úÖ Sain"
          ;;
        "unhealthy")
          echo "  ‚ùå Non sain"
          echo "  üìã Derniers checks :"
          docker inspect {{.CONTAINER_NAME}} --format='{{{{range .State.Health.Log}}}}{{{{.Start}}}} - {{{{.ExitCode}}}} - {{{{.Output}}}}{{{{end}}}}' | tail -5
          ;;
        "starting")
          echo "  üü° D√©marrage en cours"
          ;;
        "no-healthcheck")
          echo "  ‚ÑπÔ∏è  Pas de healthcheck configur√©"
          ;;
        *)
          echo "  ‚ùì √âtat inconnu ($health_status)"
          ;;
      esac

      echo ""
      echo "üíæ Utilisation des ressources :"
      docker stats {{.CONTAINER_NAME}} --no-stream --format "table {{{{.Container}}}}\t{{{{.CPUPerc}}}}\t{{{{.MemUsage}}}}\t{{{{.NetIO}}}}\t{{{{.BlockIO}}}}"

  stack:health:
    desc: "V√©rifie la sant√© globale d'une stack Docker"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Affiche un rapport de sant√© complet d'une stack Docker Swarm.

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)

      Exemple:
      task docker:monitor:stack:health STACK_NAME=production
    cmds:
    - |
      if ! docker stack ls --format "{{{{.Name}}}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        echo "üìã Stacks disponibles :"
        docker stack ls
        exit 1
      fi

      echo "üè• Rapport de sant√© de la stack '{{.STACK_NAME}}' :"
      echo ""

      echo "üîß Services :"
      docker stack services {{.STACK_NAME}} --format "table {{{{.Name}}}}\t{{{{.Replicas}}}}\t{{{{.Image}}}}"

      echo ""
      echo "üì¶ T√¢ches/Conteneurs :"
      docker stack ps {{.STACK_NAME}} --format "table {{{{.Name}}}}\t{{{{.Node}}}}\t{{{{.DesiredState}}}}\t{{{{.CurrentState}}}}"

      echo ""
      echo "üîç Analyse d√©taill√©e :"

      # Compter les services en bonne sant√©
      running_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.CurrentState}}}}" | grep -c "Running" || echo "0")
      total_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.Name}}}}" | wc -l)

      echo "  üìä T√¢ches en cours : $running_tasks/$total_tasks"

      if [ "$running_tasks" -eq "$total_tasks" ] && [ "$total_tasks" -gt 0 ]; then
        echo "  ‚úÖ Tous les services sont op√©rationnels"
      else
        echo "  ‚ö†Ô∏è  Certains services ne sont pas op√©rationnels"
        echo "  üîç Services probl√©matiques :"
        docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "table {{{{.Name}}}}\t{{{{.CurrentState}}}}" | grep -v "Running"
      fi

  containers:batch:status:
    desc: "V√©rifie le statut de plusieurs conteneurs"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      V√©rifie le statut de plusieurs conteneurs d'une liste.

      Variables:
      - CONTAINERS: Liste des conteneurs s√©par√©s par des virgules (requis)
      - STACK_NAME: Nom de la stack pour pr√©fixer les noms (optionnel)

      Exemple:
      task docker:monitor:containers:batch:status CONTAINERS="traefik,portainer,app" STACK_NAME=production
    cmds:
    - |
      if [ -z "{{.CONTAINERS}}" ]; then
        echo "‚ùå CONTAINERS est requis (ex: 'traefik,portainer,app')"
        exit 1
      fi

      echo "üìä Statut des conteneurs : {{.CONTAINERS}}"
      echo ""

      # Convertir la liste en tableau
      IFS=',' read -ra CONTAINER_ARRAY <<< "{{.CONTAINERS}}"

      for container in "${CONTAINER_ARRAY[@]}"; do
        container=$(echo "$container" | xargs)  # Trim whitespace
        
        if [ -n "{{.STACK_NAME}}" ]; then
          full_name="{{.STACK_NAME}}_${container}"
        else
          full_name="$container"
        fi
        
        echo "üîç $container :"
        
        # V√©rifier si le conteneur existe et est en cours d'ex√©cution
        if docker ps --filter "name=$full_name" --format "{{{{.Names}}}}" | grep -q "$full_name"; then
          status=$(docker ps --filter "name=$full_name" --format "{{{{.Status}}}}")
          echo "  ‚úÖ Actif - $status"
          
          # V√©rifier l'√©tat de sant√© si disponible
          health_status=$(docker inspect "$full_name" --format='{{{{.State.Health.Status}}}}' 2>/dev/null || echo "no-healthcheck")
          if [ "$health_status" != "no-healthcheck" ]; then
            case $health_status in
              "healthy") echo "  üè• Sain" ;;
              "unhealthy") echo "  üö® Non sain" ;;
              "starting") echo "  üü° V√©rification de sant√© en cours" ;;
            esac
          fi
        else
          echo "  ‚ùå Non actif ou inexistant"
        fi
        echo ""
      done

  wait:stack:ready:
    desc: "Attend qu'une stack soit compl√®tement d√©ploy√©e"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Attend que tous les services d'une stack soient dans l'√©tat "Running".

      Variables:
      - STACK_NAME: Nom de la stack (d√©faut: taskfiles-stack)
      - TIMEOUT: Timeout en secondes (d√©faut: 300)
      - CHECK_INTERVAL: Intervalle entre les v√©rifications (d√©faut: 10)

      Exemple:
      task docker:monitor:wait:stack:ready STACK_NAME=production TIMEOUT=600
    cmds:
    - |
      if ! docker stack ls --format "{{{{.Name}}}}" | grep -q "^{{.STACK_NAME}}$"; then
        echo "‚ùå La stack '{{.STACK_NAME}}' n'existe pas"
        exit 1
      fi

      echo "‚è≥ Attente que la stack '{{.STACK_NAME}}' soit pr√™te..."
      echo "üïê Timeout: {{.TIMEOUT}}s, Intervalle: {{.CHECK_INTERVAL}}s"
      echo ""

      start_time=$(date +%s)
      timeout_time=$((start_time + {{.TIMEOUT}}))

      while true; do
        current_time=$(date +%s)
        
        if [ $current_time -gt $timeout_time ]; then
          echo "‚ùå Timeout atteint ({{.TIMEOUT}}s). La stack n'est pas compl√®tement pr√™te."
          echo "üìä √âtat actuel :"
          docker stack ps {{.STACK_NAME}} --format "table {{{{.Name}}}}\t{{{{.CurrentState}}}}\t{{{{.Error}}}}"
          exit 1
        fi
        
        # Compter les t√¢ches en cours d'ex√©cution
        running_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.CurrentState}}}}" | grep -c "Running" || echo "0")
        total_tasks=$(docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "{{{{.Name}}}}" | wc -l)
        
        elapsed=$((current_time - start_time))
        echo "‚è≥ Progression: $running_tasks/$total_tasks t√¢ches pr√™tes (${elapsed}s/{{.TIMEOUT}}s)"
        
        if [ "$running_tasks" -eq "$total_tasks" ] && [ "$total_tasks" -gt 0 ]; then
          echo "‚úÖ Stack '{{.STACK_NAME}}' compl√®tement pr√™te!"
          break
        fi
        
        # Afficher les services qui ne sont pas encore pr√™ts
        echo "üîç Services en attente :"
        docker stack ps {{.STACK_NAME}} --filter "desired-state=running" --format "table {{{{.Name}}}}\t{{{{.CurrentState}}}}" | grep -v "Running" | head -3
        echo ""
        
        sleep {{.CHECK_INTERVAL}}
      done

  events:filtered:
    desc: "Surveille les √©v√©nements Docker avec filtres avanc√©s"
    silent: true
    preconditions:
    - sh: command -v docker
      msg: "Docker n'est pas install√© ou accessible"
    summary: |
      Surveille les √©v√©nements Docker avec des filtres personnalis√©s.

      Variables:
      - STACK_NAME: Filtrer par stack (optionnel)
      - EVENT_TYPES: Types d'√©v√©nements (start,stop,die,health_status, etc.)
      - SINCE: Depuis quand (ex: "2h", "2023-01-01T00:00:00")

      Exemple:
      task docker:monitor:events:filtered STACK_NAME=production EVENT_TYPES="start,stop,die"
    vars:
      EVENT_TYPES: '{{.EVENT_TYPES | default "start,stop,die,health_status"}}'
      SINCE: '{{.SINCE | default "1h"}}'
    cmds:
    - |
      echo "üì° Surveillance des √©v√©nements Docker..."
      echo "üéØ Filtres :"
      echo "   Types d'√©v√©nements: {{.EVENT_TYPES}}"
      echo "   Depuis: {{.SINCE}}"
      if [ -n "{{.STACK_NAME}}" ]; then
        echo "   Stack: {{.STACK_NAME}}"
      fi
      echo ""
      echo "‚èπÔ∏è  Appuyez sur Ctrl+C pour arr√™ter"
      echo ""

      # Construire les filtres
      filters="--since {{.SINCE}}"

      # Ajouter les filtres d'√©v√©nements
      IFS=',' read -ra EVENT_ARRAY <<< "{{.EVENT_TYPES}}"
      for event in "${EVENT_ARRAY[@]}"; do
        event=$(echo "$event" | xargs)  # Trim whitespace
        filters="$filters --filter event=$event"
      done

      # Ajouter le filtre de stack si sp√©cifi√©
      if [ -n "{{.STACK_NAME}}" ]; then
        filters="$filters --filter label=com.docker.stack.namespace={{.STACK_NAME}}"
      fi

      echo "üîç Commande: docker events $filters"
      echo ""

      docker events $filters --format "{{{{.Time}}}} [{{{{.Action}}}}] {{{{.Actor.Attributes.name}}}} ({{{{.Actor.Attributes.image}}}})"
